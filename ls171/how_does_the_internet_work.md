

**How does the Internet work?**

The Internet is a network of networks that comprises both the physical infrastructure (computers, network devices, cables, etc) and a layered system of communication protocols that enable the physical infrastructure to function.

These protocols can be grouped into layers according to the aspect of communication the protocols serve. Two models which group protocols in this way are the OSI model and the Internet Protocol Suite, or TCP/IP model.

At the highest level of both models is the Application layer. Application layer protocols such as HTTP or SMTP describe the structure that messages should have to be intelligible between networked applications using the protocol to communicate over the network (e.g. a web client and a web server).

The TCP/IP model's Application layer roughly includes the Presentation and Session layers from the OSI model. Below these is the Transport layer. Protocols at the Transport layer enable interprocess communication between networked processes (usually on different hosts). Below the Transport layer is the Network/Internet layer. The role of protocols at this layer (now almost always the Internet Protocol) is to enable inter-network communication. Below the Network/Internet layer is the Link/Data Link layer. This is the lowest layer of the TCP/IP model. The OSI model also formally includes a Physical layer below, referring to the physical infrastructure that makes up the network.

Each layer of protocols provides a service to the layer above and encapsulates data from the layer above as the data payload of a Protocol Data Unit. The Protocol Data Unit (PDU) adds metadata in the form of a header and sometimes a trailer to the data payload. For instance, the data payload of a Network layer PDU is generally the PDU of a Transport layer protocol; in turn, the PDU of the Network layer becomes the data payload of a Data Link layer PDU. The contents or structure of the data encapsulated thus are of no concern to the protocol providing the encapsulation. This encapsulation allows many different protocols at one layer to make use of a protocol at the layer below without any special considerations.

At the physical layer, data is transmitted as a stream of bits in the form of electrical signals, light signals, and radio waves. Protocols in the Data Link layer such as Ethernet give structure to data transmitted over the physical medium so that data sent over the physical network can be interpreted correctly. The role of protocols at the Data Link layer is to identify devices on the physical network and to move data over the physical network between the devices that comprise it.

The way that devices are identified, or addressed, at the Data Link layer is by MAC Address. Each device connected to a network has at least one Network Interface Card (NIC) which is assigned a number by its vendor called a MAC (Medium Access Control) Address. A MAC Address is sometimes called a physical address, or burned-in address, because it is generally fixed permanently at manufacture rather than assigned dynamically.

The smallest networks that comprise the network of networks that is the Internet are known as Local Area Networks. A simple Local Area Network (LAN) might be comprised of an office full of computers connected to a central network device called a switch. The geographic constraints imposed by the need to be connected wired or wirelessly to the central switch are what is 'local' about a Local Area Network.

For wired connections to a LAN, the most common Data Link protocol used is Ethernet. The PDU of the Ethernet protocol is called an Ethernet frame. The header of an Ethernet frame contains fields for the Source MAC Address and Destination MAC Address. When a host wishes to send some data to another host on the same LAN, the data is encapsulated as the data payload of an Ethernet frame and sent over the network via the host's NIC. The NIC is connected via Ethernet cable to the switch, which receives the frame and reads the frame header to determine which of its ports (its physical connections to hosts) should be used to forward the frame. To do this, it reads the Destination MAC Address and consults its internal MAC Address Table, which maps MAC Addresses to the switch's port numbers. The MAC Address Table is populated by reading the Source MAC Address in the headers of Ethernet frames as it receives them through its ports.

The role of the network switch is thus to direct traffic between all the hosts on the local network. However, if a host wishes to send data to a host on a different LAN, we need a router. A router is a network device that can direct traffic between different networks. For a LAN, the router acts as a gateway into and out of the network, and therefore acts as a gateway to the Internet. To do this, a router has interfaces to multiple networks between which it can route traffic using its internal Routing Table.

In order to send data between networks, we need a Network/Internet layer protocol, which is now almost always Internet Protocol (IP). IP offers inter-network addressing and routing, and encapsulation of data from the layers above into its PDU, called an IP packet. 

For the sake of simplicity, I will only discuss IP version 4. A new version, IPv6, has been in process of introduction in recent decades. IPv6's most notable improvement is a greatly expanded address space, since IPv4 addresses are limited by their 32-bit size to around 4.3 billion IP addresses and this limit already requires workarounds to serve the existing number of Internet-connected devices. An IPv4 address consists of four groups of 8 bits (octets). In the human-readable form of an IP address, each octet is represented as a number from 0 to 255 and the octets are separated by dots, e.g. `109.156.1.155`.

MAC Addresses are unsuitable as inter-network addresses because they are fixed and flat (unstructured). This works fine for LANs, since a network switch only needs to keep track of a relatively small number of directly connected hosts, each of which has a (for most practical purposes) unique MAC address. As hosts are connected and disconnected to the ports of the switch, the switch can simply update its MAC Address Table accordingly and continue. However, since routers need to be able to route a piece of data to any device on the entire Internet, the same form of addressing cannot be used. Since there is no hierarchy or structure to MAC addresses, each router would need to keep a record of the MAC Address of every networked machine on the planet in order to route the traffic to its destination. And since MAC addresses are permanently assigned, every router's impossibly vast routing table would need to be constantly updated as portable devices like laptops and phones were disconnected and reconnected on different networks at different locations.

Where MAC addresses are permanent and flat, IP addresses are logical and hierarchical. The IP address space is hierarchical in that large networks are split gradually into smaller and smaller subnetworks (via a structuring principal known as subnetting) and any given host's specific IP address reflects its position within the network as a whole. This means that a packet can easily be routed towards its destination LAN via a series of hops between routers, with each router only needing to maintain records of proximate routers in the IP network hierarchy rather than every device on the internet. IP addresses are logical in that they can be assigned and revoked as machines are connected and disconnected to different networks, with a machine's current IP address reflecting its current position within the IP network and not an immutable identity.

When a host wishes to send some data to a host on another network, the data is encapsulated as the data payload of an IP packet. The header of an IP packet includes fields for the Source IP Address, the IP address of the sender, and Destination IP address, the IP address of the host we are sending the data to. The IP packet is then encapsulated as the data payload of an Ethernet frame. The Ethernet header includes the Source MAC Address, the MAC address of the sender, and the Destination MAC Address, the MAC address of the router, or 'default gateway' out of the local network. The Ethernet frame is relayed to the local router by the switch. At this point the router strips the Ethernet header and footer, and thus de-encapsulates the IP packet. The router consults its internal Routing Table to determine the best path for the data to take for the next hop. The packet is encapsulated in another Data Link PDU and sent to the next router. This process continues, with the packet getting closer to the destination LAN with each hop across the core of the Internet, which can be thought of as a vast mesh of routers, though this is a simplification. When the packet arrives at the router that acts as gateway to the destination local network, this router then encapsulates the packet in an Ethernet frame with the MAC address of the destination host taken from its internal ARP cache. The purpose of ARP, or the Address Resolution Protocol, is to map IP addresses to MAC addresses. The frame is then relayed through the switch of the destination network and arrives at the destination host, which strips the Ethernet and IP headers and can now access the data.

Although the protocol layers of network communication covered so far allow us to get data from a host on one network to a host on another network, this doesn't account for how data gets to a delivered to a particular application running on that host. A single host may well be running many networked applications and services, and each of these processes needs to receive data from, and send data to, processes running on different hosts. IP addressing effectively provides a single channel for internet data into and out of a given host, but we need a way that multiple streams of data can be sent over this single channel and then reassembled and delivered to the correct process running on the host machine at the other end. In order for this interprocess communication between networked processes to be possible we need the Transport layer protocols, the most common of which are Transmission Control Protocol (TCP) and User Datagram Protocol. The PDU of TCP is known as a TCP Segment, while the PDU of UDP is known as a Datagram.

Both TCP and UDP offer multiplexing of multiple processes' data streams through the single channel of communication represented by the IP address of the host, as well as demultiplexing at the other end. This is achieved through a system of ports. A port is an identifier for a particular process running on a host. Both TCP segments and UDP datagrams include Source Port and Destination Port fields in their headers. When a host receives application data encapsulated in a Transport layer PDU, the host can check the port number in the Destination Port field and deliver the data to the process identified by that port. If the host needs to send data back to the process running on the other host, it can send the data to the port given in the Source Port header of the PDU it received. The combination of a Transport layer port number and a Network layer IP address forms what is known as a network socket, a communication end-point for interprocess communication between networked processes.

In addition to this multiplexing and demultiplexing, TCP offers reliable delivery of data. If we send a TCP segment to another host, we can be sure that it will eventually reach it. This is important because IP and the layers below are inherently unreliable; there is no mechanism to re-send packets that get lost in transit. TCP ensures reliable delivery over this inherently unreliable channel by providing several services: in-order data delivery, error detection through checksums, retransmission of lost data, and de-duplication of duplicate segments received due to the system of retransmissions.

To provide these services TCP uses sequence numbers to label the segments. When sending a TCP segment, the sender sets a timer. For each segment received, the receiving party sends an acknowledgement segment back to the sender with the sequence number of the segment being acknowledged included in the TCP segment header. If the sender does not receive an acknowledgement before the timer expires, the sender re-sends the unacknowledged segment. This ensures that any lost segments are re-sent until an acknowledgement is received by the sender to confirm successful receipt of the segment. However, since acknowledgments can also be lost, this can lead to duplicate segments being received. Discarding duplicates is handled through the sequence numbers, by which the receiver can recognize duplicates. The sequence numbers are also used to ensure in-order delivery of data.

TCP is a connection-oriented, client-server protocol. Maintaining a connection facilitates coordination of sequence numbers and the maintenance of state at both ends to keep track of which segments have been sent, have been acknowledged, or are in need of retransmission. This requires an initial negotiation called the 'three-way handshake' in order to establish a connection.

The three-way handshake begins with the TCP client sending a `SYN` segment (a segment with the `SYN` boolean flag in its header set to true), to the TCP server to initiate a connection. The listening server TCP socket receives the `SYN` segment and a new socket object is created defined by a four-tuple: the IP address and port number of the server and the IP address and port number of the client. This dedicated connection socket will be used for the lifetime of the connection. The server then sends back a `SYN / ACK` segment to the client. The client then sends an `ACK` segment and, at this point, application data can begin to be sent.

This whole process introduces an entire round-trip of latency before application data can begin to be sent. In addition, the system of acknowledgements, retransmissions, and in-order delivery (which can lead to Head-of-Line blocking) add a great deal of complexity. TCP ameliorates the impact on performance this complexity brings with it through mechanisms like pipelining, flow control and congestion avoidance, but there is still an impact on performance. For many applications this performance hit is worth it, but other applications may not need all of the services that TCP provides. For such applications, UDP may be a better fit.

Like TCP, UDP provides interprocess communication between networked processes, with multiplexing and demultiplexing provided by a system of port numbers. Of the reliability services that TCP provides, UDP offers only basic error detection through checksums. This unreliability makes UDP faster than TCP, but it also offers flexibility. Developers can implement only the reliability features they need on top of UDP for the specific needs of their application. UDP is a often chosen for applications like voice calling, video calling, and competitive multiplayer games, where latency (or 'lag') is a much greater problem than lost packets.

Protocols at each layer from the Physical layer to the Transport layer combine to offer reliable inter-process end-to-end communication between networked processes running on hosts on different networks around the world. These protocols make the Internet possible, but they don't in themselves define the services available on the Internet. These services require Application layer protocols. There are various services that are accessible through the Internet, with the most prominent being the World Wide Web, or simply the web. The ubiquity of the web has often lead people to confuse it with the Internet itself, but it is simply one of the services and applications the underlying Internet sustains.

When we enter a URL like `http://www.example.com/index.html` into the address bar of a web browser, a series of processes takes place before the web page can be displayed. A URL, or Uniform Resource Locator, identifies a resource on the Web. A resource is a generic term for anything that you can access on the web with a URL. A URL is a string of characters and consists of several components. The scheme (here `http`) tells the browser what family of protocols should be used in accessing the resource. The `http` scheme is related to the HTTP family of protocols, which stands for HyperText Transfer Protocol.

An Application layer protocol, HTTP is the primary protocol of the web. HTTP defines how the messages passed between web client and web server should be structured. HTTP communications follow a simple pattern called the HTTP request/response cycle. An HTTP client sends a request message to a web server and then waits for an response. The server always sends a response, even if the response is simply an error message. HTTP is a connectionless, stateless protocol, which means that each request/response cycle is treated as independent of any previous requests and responses. This means that web developers have to employ a variety of techniques to give web applications an appearance of statelessness.

After we enter `http://wwww.example.com/index.html` into the address bar, our browser prepares an HTTP request to the server named in the URL. Requests and responses are essentially text messages. The first line of the request, known as the request or start line, contains the HTTP method, the path, and the version of HTTP we are using. When, as here, we are retrieving content from the server, we generally use the `GET` HTTP method. If we were sending data to the server to alter data stored on the server, we would generally use the `POST` request. There are a handful of other methods.

As well as a scheme and a host, our URL contains a path component, `/index.html`. The path is the specific resource we are requesting from the server. In the early days of the web, paths corresponded to actual Unix-style pathnames on the web server's filesystem; this might still be the case, but since so much web content is now dynamically generated rather than static files, the path might now derive its meaning for the server from the web application logic instead of referring to an actual file.

An HTTP request may also contain headers, which are key-value pairs. From HTTP/1.1 onwards, a `Host` header became mandatory, whose value field in our case would be `www.example.com`. HTTP requests might also have a body, depending on the HTTP method used. The body contains data to be sent to the server. `GET` requests do not contain a body, though they can pass limited information to the server through the URL itself in the form of a query string. A query string component comes after the path, beginning with a `?` character, and contains key-value pairs; the query string is commonly used to pass search terms to search engines.

The host part of the URL gives the human-readable domain name of the server, but our HTTP request will need to be sent over the Internet, which relies on IP addressing. Resolving a human-readable domain name to its corresponding IP address is done by the Domain Name System (DNS). DNS is a hierarchical, distributed database that maps domain names to IP addresses. The database is distributed world-wide in a hierarchically traversable fashion, so that no single DNS server needs to keep a complete record of every domain name mapping. If the DNS server of our Internet Service Provider (ISP) does not have a record for `example.com`, the query is passed to another server further up the hierarchy, and if that server cannot find a record then the query will be passed on again, and so on until the query is resolved. 

Our HTTP request is encapsulated as the data payload of a TCP segment, whose Source Port will be randomly chosen and whose Destination Port, since we are sending our data to an HTTP server, will be port `80`. The protocols of common Internet services such as HTTP have well-known ports on which servers listen for incoming messages. Next, the TCP segment is encapsulated as the data payload of an IP packet, whose Destination IP Address is filled in thanks to a DNS query for `example.com`. The packet is then encapsulated as an Ethernet frame and sent via the switch to our router, our default gateway to other networks.

From our local router, the packet takes a series of hops between routers across the Internet and finally arrives at the router directly connected to our destination network. The packet is sent to the server, which de-encapsulates the various headers and trailers and passes the HTTP request to the web server process running on that machine. The web server processes the request and prepares an HTTP response.

An HTTP response is structured similarly to a request. Instead of a request line, the response begins with a status line, which contains a status code and accompanying status text which indicates the outcome of the request. For successful requests, this will be `200 OK`. Next, there are optional headers and an optional body. The body of the request often contains a requested resource, such as an HTML page.

When the HTTP response has been created, it will then be encapsulated in a TCP segment, which in turn is encapsulated in an IP packet and so on. The packet is sent back to the server's local gateway and back across the Internet to our router and finally to our computer. Our system strips the various headers and footers and delivers the HTTP response to our browser. The browser interprets and renders the HTML, which usually involves making additional requests for the content referenced by the HTML document: JavaScript files, CSS stylesheets, images, and so on. Each of these HyperText-referenced resources must be fetched from the server with an HTTP request/response cycle of its own.

